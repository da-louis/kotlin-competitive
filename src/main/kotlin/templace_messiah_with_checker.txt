#if (${PACKAGE_NAME} && ${PACKAGE_NAME} != "") package ${PACKAGE_NAME}#end
#set ( $FIVE_SHARP = '#####' )

import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.PrintStream

fun main() = if (localEnv && execChecker) checker() else ${NAME}()

fun #[[$END$]]#${NAME}() = solve()

@OptIn(ExperimentalStdlibApi::class)
private fun solve() = Messiah_${NAME}(MOD).exec {


    val answer = 0

    println(answer)
}

private const val MOD = 1_000_000_007

// region kokokara template dayo (^o^)
private const val execChecker = false
private val localEnv = "ENABLE_DEBUG_MODE_FOR_COMPETITIVE_PROGRAMING" in System.getenv()
private fun checker() = Messiah_${NAME}(MOD).exec {
    debugln("${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}")
    debugln("${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}  executing check mode.  ${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}")
    debugln("${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}")

    fun getOutPut(input: String, action: () -> Unit): String {
        System.setIn(ByteArrayInputStream(input.toByteArray()))
        val sysOut = ByteArrayOutputStream()
        System.setOut(PrintStream(sysOut))
        action()
        return sysOut.toString()
    }

    val wrongCases = mutableSetOf<List<String>>()

    while (wrongCases.size < 10) {
        /*
        examples
        val randomString = (1..20).map { ('a'..'z').random() }.joinToString("")
        val randomNum = Random.nextInt(0,2000)
         */
        val n = 0

        val input = buildString {
            appendln(n)
        }

        val solve = getOutPut(input, ::solve)
        val greedy = getOutPut(input, ::greedy)

        if (solve != greedy && wrongCases.add(listOf(solve, greedy))) {
            debugln("${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP} wrong case: ${DS}{wrongCases.size} ${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}${FIVE_SHARP}")
            debugln("input:")
            debugln(input)
            debugln("solve:")
            debugln(solve)
            debugln("greedy:")
            debugln(greedy)
        }
    }
}

private fun greedy() = Messiah_${NAME}(MOD).exec {
    TODO()
}

@Suppress("ClassName", "unused", "FunctionName", "PropertyName")
private class Messiah_${NAME}(private val mod: Int) {
    //////////////////////////////////////////////////
    // IO
    //////////////////////////////////////////////////
    private val input = System.`in`
    private val buffer = ByteArray(1024)
    private var pointer = 0
    private var bufferLength = 0
    private val sb = StringBuilder()
    private fun Byte.isPrintable() = this in 33..126
    private fun Byte.isNumeric() = this in '0'.toByte()..'9'.toByte()
    private fun Byte.toNumVal() = if (this.isNumeric()) this - '0'.toByte() else error("${DS}this is not numeric")
    private val lineSeparator: String = System.lineSeparator()

    private fun hasNextByte(): Boolean {
        return if (pointer < bufferLength) true else {
            pointer = 0
            bufferLength = input.read(buffer)
            bufferLength > 0
        }
    }

    private fun readByte(): Byte = if (hasNextByte()) buffer[pointer++] else -1
    private fun skipUnprintable() = run { while (hasNextByte() && !buffer[pointer].isPrintable()) pointer++ }
    private fun hasNext(): Boolean = run { skipUnprintable() }.run { hasNextByte() }
    private fun hasNextOrError() = if (!hasNext()) error("has no next element.") else Unit

    fun readString(): String {
        hasNextOrError()
        val sb = StringBuilder()
        var b = readByte()
        while (b.isPrintable()) {
            sb.appendCodePoint(b.toInt())
            b = readByte()
        }
        return sb.toString()
    }

    fun readLong(): Long {
        hasNextOrError()
        var n = 0L
        var negative = false
        var b = readByte()
        if (b == '-'.toByte()) {
            negative = true
            b = readByte()
        }
        if (!b.isNumeric()) error("${DS}b is not numeric.")
        while (true) {
            when {
                b.isNumeric() -> n = n * 10 + b.toNumVal()
                b.toInt() == -1 || !b.isPrintable() -> return if (negative) -n else n
                else -> error("failed to parse. [n=${DS}n, b=${DS}b]")
            }
            b = readByte()
        }
    }

    fun readInt() = readLong()
        .let { if (it in Int.MIN_VALUE..Int.MAX_VALUE) it.toInt() else error("${DS}it is not in range of Int.") }

    fun readIntAsIndex() = readInt().dec()

    fun readDouble(): Double {
        hasNextOrError()
        var n = 0.0
        var div = 1.0
        var negative = false
        var b = readByte()
        if (b == '-'.toByte()) {
            negative = true
            b = readByte()
        }
        do n = n * 10 + b.toNumVal()
        while (run { b = readByte() }.run { b.isNumeric() })
        if (b == '.'.toByte()) {
            while (run { b = readByte() }.run { b.isNumeric() })
                n += b.toNumVal() / (run { div *= 10 }.run { div })
        }
        return if (negative) -n else n
    }

    fun readString(size: Int): Array<String> = Array(size) { readString() }

    @Suppress("UNUSED_PARAMETER")
    fun readChars(h: Int, w: Int): Array<CharArray> = Array(h) { readString().toCharArray() }
    fun readLong(size: Int): LongArray = LongArray(size) { readLong() }
    fun readLong(h: Int, w: Int): Array<LongArray> = Array(h) { readLong(w) }
    fun readInt(size: Int): IntArray = IntArray(size) { readInt() }
    fun readInt(h: Int, w: Int): Array<IntArray> = Array(h) { readInt(w) }
    fun readIntAsIndex(size: Int): IntArray = IntArray(size) { readIntAsIndex() }
    fun readIntAsIndex(h: Int, w: Int): Array<IntArray> = Array(h) { readIntAsIndex(w) }
    fun readDouble(size: Int): DoubleArray = DoubleArray(size) { readDouble() }
    fun readDouble(h: Int, w: Int): Array<DoubleArray> = Array(h) { readDouble(w) }
    fun readBooleanWithSeparator(size: Int, trueElement: String): BooleanArray =
        BooleanArray(size) { readString() == trueElement }

    fun readBooleanWithSeparator(h: Int, w: Int, trueElement: String): Array<BooleanArray> =
        Array(h) { readBooleanWithSeparator(w, trueElement) }

    @Suppress("UNUSED_PARAMETER")
    fun readBooleanWithoutSeparator(size: Int, trueElement: Char): BooleanArray =
        readString().map { it == trueElement }.toBooleanArray()

    fun readBooleanWithoutSeparator(h: Int, w: Int, trueElement: Char): Array<BooleanArray> =
        Array(h) { readBooleanWithoutSeparator(w, trueElement) }

    fun println(): Unit = run { sb.append(lineSeparator) }
    fun print(any: Any): Unit = run { sb.append(any.toString()) }
    fun println(any: Any): Unit = run { sb.append(any.toString() + lineSeparator) }
    fun flush() = run { kotlin.io.println(sb); sb.clear() }
    fun debugln(any: Any): Unit = run { if (localEnv) System.err.println(any) }
    fun debugln(): Unit = run { if (localEnv) System.err.println() }
    fun debugln(action: () -> Unit): Unit = run { if (localEnv) action() }

    fun exec(action: Messiah_${NAME}.() -> Unit) {
        var t: Throwable? = null
        Thread(null, { action() }, "sandbox.test.solve", 128 * 1024 * 1024)
            .apply { setUncaughtExceptionHandler { _, t1 -> t = t1 } }
            .apply { start() }.join()
        t?.let { throw it }
        kotlin.io.print(sb)
    }

    fun readLine(): Nothing = error("readLine is disabled.")

    //////////////////////////////////////////////////
    // Mod
    //////////////////////////////////////////////////
    fun Long.takeMod(): Long = (this % mod).let { if (it < 0) it + mod else it }
    fun Long.plusMod(b: Long): Long = (this.takeMod() + b.takeMod()).takeMod()
    fun Long.minusMod(b: Long): Long = this.plusMod(-b)
    fun Long.timesMod(b: Long): Long = (this.takeMod()*b.takeMod()).takeMod()
    fun Long.divMod(b: Long): Long = this.timesMod(b.inv())
    fun Long.invMod(): Long = this.powMod(mod - 2L)
    fun Long.powMod(b: Long): Long {
        var x = this % mod
        var y = b
        var result = 1L
        while (y > 0) {
            if (y % 2 == 1L) result = (result * x) % mod
            y = y shr 1
            x = (x * x) % mod
        }
        return result
    }

    fun Int.takeMod(): Int = this.toLong().takeMod().toInt()
    fun Int.plusMod(b: Int): Int = this.toLong().plusMod(b.toLong()).toInt()
    fun Int.minusMod(b: Int): Int = this.toLong().minusMod(b.toLong()).toInt()
    fun Int.timesMod(b: Int): Int = this.toLong().timesMod(b.toLong()).toInt()
    fun Int.divMod(b: Int): Int = this.toLong().divMod(b.toLong()).toInt()
    fun Int.invMod(): Int = this.toLong().invMod().toInt()
    fun Int.powMod(b: Long): Int = this.toLong().powMod(b).toInt()

    //////////////////////////////////////////////////
    // Misc
    //////////////////////////////////////////////////
    /**
     * `n.indices()` is sugar syntax of `0 until n`.
     */
    val Int.indices: IntRange get() = 0 until this

    /**
     * `[index] in [this]` is sugar syntax of `index in 0 until [this]`.
     */
    operator fun Int.contains(index: Int): Boolean = index in this.indices

    /**
     * `[this].mapIndices { transform }` is sugar syntax of `(0 until [this]).map{ transform(it) }`.
     */
    inline fun <R> Int.mapIndices(transform: (Int) -> R): List<R> = this.indices.map(transform)

    /**
     * `[this].mapIndices(x) { transform }` is sugar syntax of
     * `(0 until [this]).map{ y1-> (0 until [x]).map { x1-> transform(y1,x1) } }`.
     */
    inline fun <R> Int.mapIndices(x: Int, transform: (Int, Int) -> R): List<List<R>> =
        this.mapIndices { y1 -> x.mapIndices { x1 -> transform(y1, x1) } }

    /**
     * `[this].mapIndices(x) { transform }` is sugar syntax of
     * `(0 until [this]).map{ y1-> (0 until [x]).map { x1-> transform(y1,x1) } }`.
     */
    inline fun <R> Int.flatMapIndices(x: Int, transform: (Int, Int) -> R): List<R> =
        this.indices.flatMap { y1 -> x.mapIndices { x1 -> transform(y1, x1) } }

    /**
     * `[this].forEachIndices { transform }` is sugar syntax of `(0 until [this]).map{ transform(it) }`.
     */
    inline fun Int.forEachIndices(transform: (Int) -> Unit): Unit = this.indices.forEach(transform)

    /**
     * `[this].forEachIndices(x) { transform }` is sugar syntax of
     * `(0 until [this]).map{ y1-> (0 until [x]).map { x1-> transform(y1,x1) } }`.
     */
    inline fun Int.forEachIndices(x: Int, transform: (Int, Int) -> Unit): Unit =
        this.forEachIndices { y1 -> x.forEachIndices { x1 -> transform(y1, x1) } }

    /**
     * get characters numeric value.
     * e.g.: '0' to 0
     */
    fun Char.toNumericValue(): Int = this - '0'

    fun Char.caseToIndexedValue(): Int = this - 'a'

//    fun Char.isLowerCase() = this in 'a'..'z'
//
//    fun Char.isUpperCase() = this in 'A'..'Z'

    /**
     * make triple. e.g.:`1 to 2 to 3`
     */
    infix fun <A, B, C> Pair<A, B>.to(c: C): Triple<A, B, C> = Triple(this.first, this.second, c)

    fun YesNo(b: Boolean): String = if (b) Yes else No
    val Yes = "Yes"
    val No = "No"
    fun YES_NO(b: Boolean): String = if (b) YES else NO
    val YES = "YES"
    val NO = "NO"

    fun IntArray.swap(a: Int, b: Int): Unit = run { val temp = this[a]; this[a] = this[b]; this[b] = temp }
    fun LongArray.swap(a: Int, b: Int): Unit = run { val temp = this[a]; this[a] = this[b]; this[b] = temp }
    fun CharArray.swap(a: Int, b: Int): Unit = run { val temp = this[a]; this[a] = this[b]; this[b] = temp }
    fun <T> Array<T>.swap(a: Int, b: Int): Unit = run { val temp = this[a]; this[a] = this[b]; this[b] = temp }
    fun <T> MutableList<T>.swap(a: Int, b: Int): Unit = run { val temp = this[a]; this[a] = this[b]; this[b] = temp }

    fun IntArray.changeMinOf(i: Int, v: Int): Unit = run { this[i] = kotlin.math.min(this[i], v) }
    fun IntArray.changeMaxOf(i: Int, v: Int): Unit = run { this[i] = kotlin.math.max(this[i], v) }
    fun LongArray.changeMinOf(i: Int, v: Long): Unit = run { this[i] = kotlin.math.min(this[i], v) }
    fun LongArray.changeMaxOf(i: Int, v: Long): Unit = run { this[i] = kotlin.math.max(this[i], v) }

    fun IntArray.plusAssignMod(i: Int, v: Int): Unit = run { this[i] = this[i].plusMod(v) }
    fun IntArray.minusAssignMod(i: Int, v: Int): Unit = run { this[i] = this[i].minusMod(v) }
    fun IntArray.timesAssignMod(i: Int, v: Int): Unit = run { this[i] = this[i].timesMod(v) }
    fun IntArray.divAssignMod(i: Int, v: Int): Unit = run { this[i] = this[i].divMod(v) }
    fun IntArray.powAssignMod(i: Int, v: Long): Unit = run { this[i] = this[i].powMod(v) }

    fun LongArray.plusAssignMod(i: Int, v: Int): Unit = run {
        this[i] = (this[i] % mod).toInt().plusMod(v).toLong()
    }

    fun LongArray.minusAssignMod(i: Int, v: Int): Unit = run {
        this[i] = (this[i] % mod).toInt().minusMod(v).toLong()
    }

    fun LongArray.timesAssignMod(i: Int, v: Int): Unit = run {
        this[i] = (this[i] % mod).toInt().timesMod(v).toLong()
    }

    fun LongArray.divAssignMod(i: Int, v: Int): Unit = run {
        this[i] = (this[i] % mod).toInt().divMod(v).toLong()
    }

    fun LongArray.powAssignMod(i: Int, v: Long): Unit = run {
        this[i] = (this[i] % mod).toInt().powMod(v).toLong()
    }

    /**
     * same usage as `IntArray.scan`, but it will faster than that.
     */
    inline fun IntArray.scanArray(initial: Int, operation: (acc: Int, Int) -> Int): IntArray {
        val accumulator = IntArray(this.size + 1).apply { this[0] = initial }
        for (i in this.indices) accumulator[i + 1] = operation(accumulator[i], this[i])
        return accumulator
    }

    /**
     * same usage as `LongArray.scan`, but it will faster than that.
     */
    inline fun LongArray.scanArray(initial: Long, operation: (acc: Long, Long) -> Long): LongArray {
        val accumulator = LongArray(this.size + 1).apply { this[0] = initial }
        for (i in this.indices) accumulator[i + 1] = operation(accumulator[i], this[i])
        return accumulator
    }

    /**
     * same usage as `IntArray.scanReduce`, but it will faster than that.
     */
    inline fun IntArray.scanReduceArray(operation: (acc: Int, Int) -> Int): IntArray {
        val accumulator = IntArray(this.size).apply { this[0] = this@scanReduceArray[0] }
        for (i in 1..this.lastIndex) accumulator[i] = operation(accumulator[i - 1], this[i])
        return accumulator
    }

    /**
     * same usage as `LongArray.scanReduce`, but it will faster than that.
     */
    inline fun LongArray.scanReduceArray(operation: (acc: Long, Long) -> Long): LongArray {
        val accumulator = LongArray(this.size).apply { this[0] = this@scanReduceArray[0] }
        for (i in 1..this.lastIndex) accumulator[i] = operation(accumulator[i - 1], this[i])
        return accumulator
    }
}
// endregion kokomade template dayo (^o^)
